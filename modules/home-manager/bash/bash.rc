#!/usr/bin/env bash

# Warn if the user is running a version of bash older than 5.3
if [[ ${BASH_VERSINFO[0]} -lt 5 || ( ${BASH_VERSINFO[0]} -eq 5 && ${BASH_VERSINFO[1]} -lt 3 ) ]]; then
    echo -e "\e[31mWARNING: You are using bash version ${BASH_VERSION}. This config requires bash 5.3 or newer.\e[0m"
fi

#    ▗▄▄▖ ▗▄▄▄▖ ▗▄▖ ▗▄▄▄ ▗▖   ▗▄▄▄▖▗▖  ▗▖▗▄▄▄▖
#    ▐▌ ▐▌▐▌   ▐▌ ▐▌▐▌  █▐▌     █  ▐▛▚▖▐▌▐▌
#    ▐▛▀▚▖▐▛▀▀▘▐▛▀▜▌▐▌  █▐▌     █  ▐▌ ▝▜▌▐▛▀▀▘
#    ▐▌ ▐▌▐▙▄▄▖▐▌ ▐▌▐▙▄▄▀▐▙▄▄▖▗▄█▄▖▐▌  ▐▌▐▙▄▄▖

bind "set completion-ignore-case on"    # Do not differentiate between upper and lower case when completing
bind "set echo-control-characters off"  # Do not print out control characters in a visible format (e.g. ^C)
bind "TAB: menu-complete"               # Use TAB to auto-complete
bind "set skip-completed-text on"       # When performing completion in the middle of a word move the cursor past the completed text instead of
                                        # inserting the completed text at the cursor position. For example if your cursor was after the u in cd
                                        # modules it will just move your cursor to the end instead of changing it to cd modulesles.
bind '"\e[A": history-search-backward'  # Use ↑ to search backwards through your history for the text in the prompt
bind '"\e[B": history-search-forward'   # Use ↓ to search forwards through your history for the text in the prompt
bind '"\C-h": backward-kill-word'       # Use Ctrl+Backspace to delete the last word in the prompt
bind '"\e[1;3D": "cd ..\n"'             # Use Alt+← to go up one directory
bind '"\e[1;3C": "cd -\n"'              # Use Alt+→ to go to the previous directory
bind '"\es": "\C-asudo \C-e"'           # Use Alt+s to prepend sudo to the current command
bind '"\C-l": clear-display'            # Use Ctrl+L to clear the screen (override the default clear-screen, which does just scrolls the screen up)
bind '"\C-r": "source ~/nix/modules/home-manager/bash/bash.rc\n"'     # Use Ctrl+R to reload the bashrc file from my nix configuration

# bind "set editing-mode vi"              # Use vi keybindings in the terminal (seems to prevent the use of the up and down arrow keys)
# bind "set show-all-if-ambiguous on"     # print out all matching files/directories if there are multiple possibilities
# bind "set colored-stats on"             # show directories in a different color when show-all-if-ambiguous is enabled
# bind "set colored-completion-prefix on" # show the part of the completed text that was already typed in a different color when show-all-if-ambiguous is enabled

#     ▗▄▄▖▗▖   ▗▄▄▄▖     ▗▄▖ ▗▖  ▗▖▗▄▄▄▖▗▄▄▖ ▗▖    ▗▄▖▗▖  ▗▖▗▄▄▖
#    ▐▌   ▐▌     █      ▐▌ ▐▌▐▌  ▐▌▐▌   ▐▌ ▐▌▐▌   ▐▌ ▐▌▝▚▞▘▐▌
#    ▐▌   ▐▌     █      ▐▌ ▐▌▐▌  ▐▌▐▛▀▀▘▐▛▀▚▖▐▌   ▐▛▀▜▌ ▐▌  ▝▀▚▖
#    ▝▚▄▄▖▐▙▄▄▖▗▄█▄▖    ▝▚▄▞▘ ▝▚▞▘ ▐▙▄▄▖▐▌ ▐▌▐▙▄▄▖▐▌ ▐▌ ▐▌ ▗▄▄▞▘

_find_parent_venv() {
    local dir="$PWD"
    while [[ -n $dir ]]; do
        if [[ -f "$dir/$1/bin/activate" ]]; then
            echo "$dir/$1"
            return 0
        fi
        dir="${dir%/*}" # faster than dir=$(dirname "$dir") because it avoids a sub-shell
    done
    return 1
}

# Add the ability to cd up several directories using additional dots after cd ..
# For example, cd ... goes up two directories
cd() {
    if [[ $1 == ..+(.) ]]; then # requires extglob to be enabled
        # Use builtin to prevent infinite recursion
        # printf '../%.0s' generates ../ for space separated value that follows. ${#1} is the length of $1
        builtin cd "${ printf "../%.0s" ${ seq 2 ${#1}; }; }" || return
    else
        builtin cd "$@" || return
    fi
    # Post cd hooks

    # Auto-activate Python venvs in current or parent directories
    local found_venv=${ _find_parent_venv ".venv"; }
    if [[ -n $found_venv ]]; then
        # Activate if not already active or different env
        if [[ -z $VIRTUAL_ENV || $VIRTUAL_ENV != "$found_venv" ]]; then
            # shellcheck disable=SC1091
            source "$found_venv/bin/activate"
        fi
    elif [[ -n $VIRTUAL_ENV ]]; then
        deactivate
    fi
}

# man() {
#     # TODO: Account for things like test that are both builtins and executables - I want the man page of the exe in that case
#     # TODO: Maybe use help -m instead of --help for builtins. Learn more about help first.

#     # TODO: Account for man parameters or multiple arguments
#     declare -A types
#     while IFS= read -r line; do
#         if [[ $line == "$1 is aliased to "* ]]; then
#             types["alias"]=true
#         elif [[ $line == "$1 is a function" ]]; then
#             types["function"]=true
#         elif [[ $line == "$1 is a shell builtin" ]]; then
#             types["builtin"]=true
#         elif [[ $line == "$1 is /"* || $line == "$1 is ./"* ]]; then
#             types["executable"]=true
#         fi
#     done < <(type -a "$1")

#     if [[ -v types["alias"] ]]; then
#         local alias_exp=${ alias $1; }
#         local start_index=$((${#1} + 8)) # 8 is length of "alias x='"
#         bat --language man --plain <<< $'\nALIAS'
# 		bat -l bash -f --plain <<< "${alias_exp:$start_index:-1}" | xargs -I % echo "    $1='%'"
#     fi
#     if [[ -v types["function"] ]]; then
#         if [[ -v types["builtin"] || -v types["executable"] ]]; then
#             bat --language man --plain <<< $'\nWRAPPER\x20FUNCTION' # if I use literal space instead of \x20 syntax highlighting in IDE breaks
#         else
#             bat --language man --plain <<< $'\nFUNCTION'
#         fi
#         bat -l bash -f --plain < <(declare -f "$1" | awk '{print "    " $0}')
#     fi
#     if [[ -v types["builtin"] ]]; then
#         col -bx < <(echo; help -m "$1") | bat --language man --plain
#     elif [[ -v types["executable"] ]]; then
#         # if [[ ! -v types["alias"] && ! -v types["function"] ]]; then
#         command man "$@" 2> /dev/null
#         if [[ $? -ne 0 ]]; then
#             "$1" --help 2> /dev/null
#             if [[ $? -eq 0 ]]; then
#                 echo
#                 echo -e "\e[31mNOTE: This is an executable that does not have a man page.\e[0m"
#                 echo -e "\e[31m      You are seeing the text from \e[0m$1 --help\e[31m thanks to my man wrapper function.\e[0m"
#             else
#                 echo -e "\e[31mNOTE: This executable does not have a man page or help text.\e[0m"
#             fi
#         fi
#     fi
# 		# NOTES
# 		# EOF
#         # echo -e "        \e[31mAliases do not have man pages or help text. You are seeing this pseudo man page\e[0m"
#         # echo -e "        \e[31mthanks to my man wrapper function. Run \e[0malias $1\e[31m to see the alias definition.\e[0m"
#     return
#     if [[ ${ type -t $1; } == "builtin" ]]; then
#         help -m "$1" | col -bx | bat --language man --plain
#         if [[ $? -eq 0 ]]; then
#             echo
#             echo -e "\e[31mNOTE: This is a builtin command which means it does not have a man page.\e[0m"
#             echo -e "\e[31m      You are seeing the text from $1 --help thanks to my man wrapper function.\e[0m"
#         fi
#         return
#     fi
#     command man "$@" 2> /dev/null
#     if [[ $? -ne 0 ]]; then
#         "$1" --help
#         if [[ $? -eq 0 ]]; then
#             echo
#             echo -e "\e[31mNOTE: This is a function or executable that does not have a man page.\e[0m"
#             echo -e "\e[31m      You are seeing the text from $1 --help thanks to my man wrapper function.\e[0m"
#         fi
#     fi
# }

# If nix-shell is run without --run, --command or --pure then automatically start an interactive bash shell (so .bashrc is sourced)
nix-shell() {
    if [[ " $* " == *" --run "* || " $* " == *" --command "* || " $* " == *" --pure "* ]]; then
        command nix-shell "$@"
    else
        command nix-shell "$@" --run "bash -i"
    fi
}

#  ▗▄▄▖  ▗▄▖  ▗▄▄▖▗▖ ▗▖    ▗▄▄▖ ▗▄▄▖  ▗▄▖ ▗▖  ▗▖▗▄▄▖▗▄▄▄▖
#  ▐▌ ▐▌▐▌ ▐▌▐▌   ▐▌ ▐▌    ▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌▐▛▚▞▜▌▐▌ ▐▌ █
#  ▐▛▀▚▖▐▛▀▜▌ ▝▀▚▖▐▛▀▜▌    ▐▛▀▘ ▐▛▀▚▖▐▌ ▐▌▐▌  ▐▌▐▛▀▘  █
#  ▐▙▄▞▘▐▌ ▐▌▗▄▄▞▘▐▌ ▐▌    ▐▌   ▐▌ ▐▌▝▚▄▞▘▐▌  ▐▌▐▌    █

_parse_git_status() {
    echo -n " "
    if ! git rev-parse --is-inside-work-tree &> /dev/null; then return; fi
    local short=${ [[ $1 == "-s" || $1 == "--short" ]] && echo true || echo false; }
    declare -a statuses
    declare -a icons=("" "" "" "" "" "󱈸" "")
    declare -a short_icons=("*" "+" "-" "󰫿" "󰫰" "!" "?")

    while IFS="" read -r line; do
        local status=${line:0:2}
        case $status in
            M*|*M) ((statuses[0] += 1)) ;; # Modified  * / 
            A*|*A) ((statuses[1] += 1)) ;; # Added     + / 
            D*|*D) ((statuses[2] += 1)) ;; # Deleted   - / 
            R*|*R) ((statuses[3] += 1)) ;; # Renamed   󰫿 / 
            C*|*C) ((statuses[4] += 1)) ;; # Copied    󰫰 / 
            U*|*U) ((statuses[5] += 1)) ;; # Unmerged  ! / 󱈸 (conflicts)
            \?\?) ((statuses[6] += 1)) ;; #  Untracked ? / 
        esac
    done < <(git status -s --porcelain)
    # Array only has indices where values were assigned, & ! before array ref gets indices
    for i in "${!statuses[@]}"; do
        if $short; then
            echo -n "${short_icons[$i]}"
        else
            echo -n "${statuses[$i]}${icons[$i]} "
        fi
    done
    echo ""
}

_parse_git_branch() {
    echo -n " "
    # Get branch name if in git repo
    local branch=${ git rev-parse --abbrev-ref HEAD 2>/dev/null; }
    if [[ -z $branch ]]; then return; fi

    # Check if in a detached HEAD state
    if [[ $branch == "HEAD" ]]; then
        # Get current commit hash
        local commit_hash=${ git rev-parse --short HEAD 2>/dev/null; }
        if [[ $commit_hash == "" ]]; then
            echo "  "
        else
            echo " $commit_hash "
        fi
    elif git rev-parse "@{u}" &> /dev/null; then # Check if branch has upstream
        # Get ahead/behind status
        local status=${ git status -sb --porcelain; }
        local ahead_behind=""
        if [[ $status =~ \[ahead\ [0-9]+ ]]; then
            local ahead_count=${ echo "$status" | grep -oP '(?<=\[ahead )\d+'; }
            ahead_behind="↑$ahead_count"
        fi
        if [[ $status =~ behind\ [0-9]+\] ]]; then
            local behind_count=${ echo "$status" | grep -oP '(?<=behind )\d+(?=\])'; }
            ahead_behind="$ahead_behind↓$behind_count"
        fi
        echo " $branch $ahead_behind"
    else
        echo " $branch 󱄁 "
    fi
}

# Alternative to \w that prints the current directory in a more concise way:
# Print / or ~ if we are in the root or home directory
# Print the exact path if we are in a subdirectory of root or home
# Print /…/directory if we are in a subdirectory of a subdirectory of root
# Print ~/…/directory if we are in a subdirectory of a subdirectory of home
# Print ~/<icon>/directory if we are in a subdirectory of a subdirectory of home and the home subdirectory has an icon
# Print ~/<icon>/…/directory if we are more than 2 subdirectories deep in home and the home subdirectory has an icon
_parse_directory() {
    echo -n " "
    local directory=${PWD##*/} # same as basename "$PWD"
    local parent_dir=${ basename "${PWD%/*}"; }
    if [[ $PWD == "$HOME"* ]]; then # if we are in a subdirectory of a subdirectory of home
        if [[ $PWD = "$HOME" ]]; then
            echo "~ "
            return
        elif [[ $PWD = "$HOME/$directory" ]]; then # if we are in a subdirectory of home
            # shellcheck disable=SC2088
            echo "~/$directory "
            return
        fi
        local home_subdir=${ echo "${PWD#"$HOME"/}" | cut -d "/" -f 1; } # get first subdirectory after home
        local icon="${DIR_ICONS[$home_subdir]} "
        if [[ -n $icon ]]; then # if the parent directory has an icon
            if [[ $PWD = "$HOME/$parent_dir/$directory" ]]; then
                # shellcheck disable=SC2088
                echo "~/$icon/$directory "
            else
                # shellcheck disable=SC2088
                echo "~/$icon/…/$directory "
            fi
        else
            # shellcheck disable=SC2088
            echo "~/…/$directory "
        fi
    else # if we are in a subdirectory of root
        if [[ $PWD = "/" || $PWD = "/$directory" ]]; then
            echo "$PWD "
            return
        fi
        local subdir=${ echo "$PWD" | cut -d "/" -f 2; } # get root subdirectory
        local icon="${DIR_ICONS[$subdir]} "
        if [[ -n $icon ]]; then # if the parent directory has an icon
            if [[ $PWD = "/$parent_dir/$directory" ]]; then
                echo "/$icon/$directory "
            else
                echo "/$icon/…/$directory "
            fi
        else
            echo "/…/$directory "
        fi
    fi
}

distro_icon() {
    case "${ uname -s; }" in
        Linux*)
            if [[ -d /system && -d /data ]]; then
                local distro="termux"
            elif [[ -e "/etc/os-release" ]]; then
                local distro=$(source /etc/os-release && echo "$ID")
            else
                local distro="linux"
            fi
            ;;
        CYGWIN*|MINGW*|MSYS*)
            local distro="windows"
            ;;
        *)
            local distro="unknown"
            ;;
    esac
    declare -A distro_icons=(
        ["debian"]=" "
        ["ubuntu"]=" "
        ["nixos"]=" "
        ["termux"]=" "
        ["windows"]=" "
        ["linux"]=" "
    )
    declare -A distro_colors=(
        ["debian"]="168;0;48"
        ["ubuntu"]="233;84;32"
        ["nixos"]="126;183;226"
        ["termux"]="164;198;57"
        ["windows"]="0;173;239"
        ["linux"]="255;255;0"
    )
    local icon="${distro_icons[$distro]}"
    local color="${distro_colors[$distro]:-0;0;0}"
    unset distro_icons distro_colors
    echo "\[\e[38;2;${color}m\]${icon}"
}

# Timer for measuring the time it takes to run a command
_timer_start() {
    [[ -n $COMP_LINE ]] && return # do nothing if completing
    [[ $BASH_COMMAND = "$PROMPT_COMMAND" ]] && return
    timer=${ date +%s%3N; }
}

# Stop the timer and print the time it took to run the command in a human readable format
_timer_stop() {
    local end_time=${ date +%s%3N; }
    if [[ -z $timer ]]; then
        echo "-"
        return
    fi
    local T MS S M H D result
    ((T = end_time - timer))
    ((MS = T % 1000))
    ((S = T / 1000 % 60))
    ((M = T / 1000 / 60 % 60))
    ((H = T / 1000 / 60 / 60 % 24))
    ((D = T / 1000 / 60 / 60 / 24))

    ((D > 0)) && result+="${D}d "
    ((H > 0)) && result+="${H}h "
    ((M > 0)) && result+="${M}m "
    ((S > 0)) && result+="${S}s "
    result+="${MS}ms"
    echo "$result"
}

# Function that runs just before the prompt is displayed
_prompt_command() {
    local exit_code=$?
    _DURATION="  ${ _timer_stop; } "
    unset timer
    if [[ $exit_code -eq 0 ]]; then
        _EXIT_BG="20;184;121" # green
        _EXIT_FG="0;0;0"
    elif [[ $exit_code -eq 130 ]]; then # 130 is the exit code for Ctrl+C
        _EXIT_BG="204;166;51" # yellow
        _EXIT_FG="0;0;0"
    else
        _EXIT_BG="205;49;49" #  red
        _EXIT_FG="255;255;255"
    fi
    # Sync bash history between all open terminals
    history -a   # Append this sessions bash history to the history file
    history -n   # Read new lines other sessions have added to the bash history file
}

# Run _timer_start before each simple command (DEBUG) and before each interrupt (INT, i.e. Ctrl+C)
trap _timer_start DEBUG INT
# PROMPT_COMMAND must be a single command so that it matches BASH_COMMAND in _timer_start, otherwise the timer will be
# reset just before it is stopped because the DEBUG trap is triggered by PROMPT_COMMAND
PROMPT_COMMAND="_prompt_command"
