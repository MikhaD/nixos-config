#    ▗▄▄▖ ▗▄▄▄▖ ▗▄▖ ▗▄▄▄ ▗▖   ▗▄▄▄▖▗▖  ▗▖▗▄▄▄▖
#    ▐▌ ▐▌▐▌   ▐▌ ▐▌▐▌  █▐▌     █  ▐▛▚▖▐▌▐▌
#    ▐▛▀▚▖▐▛▀▀▘▐▛▀▜▌▐▌  █▐▌     █  ▐▌ ▝▜▌▐▛▀▀▘
#    ▐▌ ▐▌▐▙▄▄▖▐▌ ▐▌▐▙▄▄▀▐▙▄▄▖▗▄█▄▖▐▌  ▐▌▐▙▄▄▖

bind "set completion-ignore-case on"    # Do not differentiate between upper and lower case when completing
bind "set echo-control-characters off"  # Do not print out control characters in a visible format (e.g. ^C)
bind "TAB: menu-complete"               # Use TAB to auto-complete
bind "set skip-completed-text on"       # When performing completion in the middle of a word move the cursor past the completed text instead of
                                        # inserting the completed text at the cursor position. For example if your cursor was after the u in cd
                                        # modules it will just move your cursor to the end instead of changing it to cd modulesles.
bind '"\e[A": history-search-backward'  # Use ↑ to search backwards through your history for the text in the prompt
bind '"\e[B": history-search-forward'   # Use ↓ to search forwards through your history for the text in the prompt
bind '"\C-h": backward-kill-word'       # Use Ctrl+Backspace to delete the last word in the prompt
bind '"\e[1;3D": "cd ..\n"'             # Use Alt+← to go up one directory
bind '"\e[1;3C": "cd -\n"'              # Use Alt+→ to go to the previous directory
bind '"\es": "\C-asudo \C-e"'           # Use Alt+s to prepend sudo to the current command
bind '"\C-l": clear-display'            # Use Ctrl+L to clear the screen (override the default clear-screen, which does just scrolls the screen up)
bind '"\C-r": "source ~/nix/modules/home-manager/bash/bash.rc\n"'     # Use Ctrl+R to reload the bashrc file from my nix configuration

# bind "set editing-mode vi"              # Use vi keybindings in the terminal (seems to prevent the use of the up and down arrow keys)
# bind "set show-all-if-ambiguous on"     # print out all matching files/directories if there are multiple possibilities
# bind "set colored-stats on"             # show directories in a different color when show-all-if-ambiguous is enabled
# bind "set colored-completion-prefix on" # show the part of the completed text that was already typed in a different color when show-all-if-ambiguous is enabled

#     ▗▄▄▖▗▖   ▗▄▄▄▖     ▗▄▖ ▗▖  ▗▖▗▄▄▄▖▗▄▄▖ ▗▖    ▗▄▖▗▖  ▗▖▗▄▄▖
#    ▐▌   ▐▌     █      ▐▌ ▐▌▐▌  ▐▌▐▌   ▐▌ ▐▌▐▌   ▐▌ ▐▌▝▚▞▘▐▌
#    ▐▌   ▐▌     █      ▐▌ ▐▌▐▌  ▐▌▐▛▀▀▘▐▛▀▚▖▐▌   ▐▛▀▜▌ ▐▌  ▝▀▚▖
#    ▝▚▄▄▖▐▙▄▄▖▗▄█▄▖    ▝▚▄▞▘ ▝▚▞▘ ▐▙▄▄▖▐▌ ▐▌▐▙▄▄▖▐▌ ▐▌ ▐▌ ▗▄▄▞▘

_find_parent_virtualenv() {
    local dir="$PWD"
    while [[ -n $dir ]]; do
        if [[ -f "$dir/$1/bin/activate" ]]; then
            echo "$dir/$1"
            return 0
        fi
        dir="${dir%/*}" # faster than dir=$(dirname "$dir") because it avoids a subshell
    done
    return 1
}

# Add the ability to cd up several directories using additional dots after cd ..
# For example, cd ... goes up two directories
cd() {
    if [[ $1 == ..+(.) ]]; then # requires extglob to be enabled
        # Use builtin to prevent infinite recursion
        # printf '../%.0s' generates ../ for space separated value that follows. ${#1} is the length of $1
        builtin cd $(printf "../%.0s" $(seq 2 ${#1}))
    else
        builtin cd "$@"
    fi
    # Post cd hooks

    # Auto-activate Python venvs in current or parent directories
    local found_venv=$(_find_parent_virtualenv ".venv")
    if [[ -n $found_venv ]]; then
        # Activate if not already active or different env
        if [[ -z $VIRTUAL_ENV || $VIRTUAL_ENV != "$found_venv" ]]; then
            source "$found_venv/bin/activate"
        fi
    elif [[ -n $VIRTUAL_ENV ]]; then
        deactivate
    fi
}

# If nix-shell is run without --run, --command or --pure then automatically start an interactive bash shell (so .bashrc is sourced)
nix-shell() {
    if [[ " $* " == *" --run "* || " $* " == *" --command "* || " $* " == *" --pure "* ]]; then
        command nix-shell "$@"
    else
        command nix-shell "$@" --run "bash -i"
    fi
}

#  ▗▄▄▖  ▗▄▖  ▗▄▄▖▗▖ ▗▖    ▗▄▄▖ ▗▄▄▖  ▗▄▖ ▗▖  ▗▖▗▄▄▖▗▄▄▄▖
#  ▐▌ ▐▌▐▌ ▐▌▐▌   ▐▌ ▐▌    ▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌▐▛▚▞▜▌▐▌ ▐▌ █
#  ▐▛▀▚▖▐▛▀▜▌ ▝▀▚▖▐▛▀▜▌    ▐▛▀▘ ▐▛▀▚▖▐▌ ▐▌▐▌  ▐▌▐▛▀▘  █
#  ▐▙▄▞▘▐▌ ▐▌▗▄▄▞▘▐▌ ▐▌    ▐▌   ▐▌ ▐▌▝▚▄▞▘▐▌  ▐▌▐▌    █

_parse_git_status() {
    echo -n " "
    if ! git rev-parse --is-inside-work-tree &> /dev/null; then return; fi
    local short=$([[ $1 == "-s" || $1 == "--short" ]] && echo true || echo false)
    declare -a statuses
    declare -a icons=("" "" "" "" "" "󱈸" "")
    declare -a short_icons=("*" "+" "-" "󰫿" "󰫰" "!" "?")

    while IFS="" read -r line; do
        local status=${line:0:2}
        case $status in
            M*|*M) ((statuses[0] += 1)) ;;       # Modified  * / 
            A*|*A) ((statuses[1] += 1)) ;;       # Added     + / 
            D*|*D) ((statuses[2] += 1)) ;;       # Deleted   - / 
            R*|*R) ((statuses[3] += 1)) ;;       # Renamed   󰫿 / 
            C*|*C) ((statuses[4] += 1)) ;;       # Copied    󰫰 / 
            U*|*U|AA|DD) ((statuses[5] += 1)) ;; # Unmerged  ! / 󱈸 (conflicts)
            \?\?) ((statuses[6] += 1)) ;;        # Untracked ? / 
        esac
    done < <(git status -s --porcelain)
    # Array only has indices where values were assigned, & ! before array ref gets indices
    for i in "${!statuses[@]}"; do
        if $short; then
            echo -n "${short_icons[$i]}"
        else
            echo -n "${statuses[$i]}${icons[$i]} "
        fi
    done
    echo ""
}

_parse_git_branch() {
    echo -n " "
    # Get branch name if in git repo
    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [[ -z $branch ]]; then return; fi

    # Check if in a detached HEAD state
    if [[ $branch == "HEAD" ]]; then
        # Get current commit hash
        local commit_hash=$(git rev-parse --short HEAD 2>/dev/null)
        if [[ $commit_hash == "" ]]; then
            echo "  "
        else
            echo " $commit_hash "
        fi
    elif git rev-parse @{u} &> /dev/null; then # Check if branch has upstream
        # Get ahead/behind status
        local status=$(git status -sb --porcelain)
        local ahead_behind=""
        if [[ $status =~ \[ahead\ [0-9]+ ]]; then
            local ahead_count=$(echo $status | grep -oP '(?<=\[ahead )\d+')
            ahead_behind="↑$ahead_count"
        fi
        if [[ $status =~ behind\ [0-9]+\] ]]; then
            local behind_count=$(echo $status | grep -oP '(?<=behind )\d+(?=\])')
            ahead_behind="$ahead_behind↓$behind_count"
        fi
        echo " $branch $ahead_behind"
    else
        echo " $branch 󱄁 "
    fi
}

# Alternative to \w that prints the current directory in a more concise way:
# Print / or ~ if we are in the root or home directory
# Print the exact path if we are in a subdirectory of root or home
# Print /…/directory if we are in a subdirectory of a subdirectory of root
# Print ~/…/directory if we are in a subdirectory of a subdirectory of home
# Print ~/<icon>/directory if we are in a subdirectory of a subdirectory of home and the home subdirectory has an icon
# Print ~/<icon>/…/directory if we are more than 2 subdirectories deep in home and the home subdirectory has an icon
_parse_directory() {
    echo -n " "
    local directory=$(basename "$PWD")
    local parent_dir=$(basename "$(dirname "$PWD")")
    if [[ $PWD == "$HOME"* ]]; then # if we are in a subdirectory of a subdirectory of home
        if [[ $PWD = $HOME ]]; then
            echo "~ "
            return
        elif [[ $PWD = "$HOME/$directory" ]]; then # if we are in a subdirectory of home
            echo "~/$directory "
            return
        fi
        local home_subdir=$(echo ${PWD#$HOME/} | cut -d "/" -f 1)
        local icon="${DIR_ICONS[$home_subdir]} "
        if [[ -n $icon ]]; then # if the parent directory has an icon
            if [[ $PWD = "$HOME/$parent_dir/$directory" ]]; then
                echo "~/$icon/$directory "
            else
                echo "~/$icon/…/$directory "
            fi
        else
            echo "~/…/$directory "
        fi
    else # if we are in a subdirectory of root
        if [[ $PWD = "/" || $PWD = "/$directory" ]]; then
            echo "$PWD "
            return
        fi
        local subdir=$(echo $PWD | cut -d "/" -f 2)
        local icon="${DIR_ICONS[$subdir]} "
        if [[ -n $icon ]]; then # if the parent directory has an icon
            if [[ $PWD = "/$parent_dir/$directory" ]]; then
                echo "/$icon/$directory "
            else
                echo "/$icon/…/$directory "
            fi
        else
            echo "/…/$directory "
        fi
    fi
}

distro_icon() {
    case "$(uname -s)" in
        Linux*)
            if [[ -d /system && -d /data ]]; then
                local distro="termux"
            elif [[ -e "/etc/os-release" ]]; then
                local distro=$(source /etc/os-release && echo $ID)
            else
                local distro="linux"
            fi
            ;;
        CYGWIN*|MINGW*|MSYS*)
            local distro="windows"
            ;;
        *)
            local distro="unknown"
            ;;
    esac
    declare -A distro_icons=(
        ["debian"]=" "
        ["ubuntu"]=" "
        ["nixos"]=" "
        ["termux"]=" "
        ["windows"]=" "
        ["linux"]=" "
    )
    declare -A distro_colors=(
        ["debian"]="168;0;48"
        ["ubuntu"]="233;84;32"
        ["nixos"]="126;183;226"
        ["termux"]="164;198;57"
        ["windows"]="0;173;239"
        ["linux"]="255;255;0"
    )
    local icon="${distro_icons[$distro]}"
    local color="${distro_colors[$distro]:-0;0;0}"
    unset distro_icons distro_colors
    echo "\[\e[38;2;${color}m\]${icon}"
}

# Function that displays 󰢹 before the prompt if the terminal is being accessed via SSH
ssh_session() {
    if [[ -n $SSH_CLIENT ]]; then
        echo "\[\e[94m\]󰢹 \[\e[0m\]";
    fi
}

# Function that displays  before the prompt if we are in a nix shell, or  󰌪 if we are in a pure nix shell (pure: no system software included)
nix_shell() {
    if [[ -n $IN_NIX_SHELL ]]; then
        local pure=$(test "$IN_NIX_SHELL" = "pure" && echo "󰌪 ")
        echo "\[\e[38;2;126;183;226m\] \[\e[38;2;159;226;126m\]$pure\[\e[0m\]"
    fi
}

# Timer for measuring the time it takes to run a command
_timer_start() {
    [[ -n $COMP_LINE ]] && return # do nothing if completing
    [[ $BASH_COMMAND = $PROMPT_COMMAND ]] && return
    timer=$(date +%s%3N)
}

# Stop the timer and print the time it took to run the command in a human readable format
_timer_stop() {
    local end_time=$(date +%s%3N)
    if [[ -z $timer ]]; then
        echo "-"
        return
    fi
    local T=$((end_time - timer))
    local MS=$((T % 1000))
    local S=$((T / 1000 % 60))
    local M=$((T / 1000 / 60 % 60))
    local H=$((T / 1000 / 60 / 60 % 24))
    local D=$((T / 1000 / 60 / 60 / 24))
    local result=""
    ((D > 0)) && result+="${D}d "
    ((H > 0)) && result+="${H}h "
    ((M > 0)) && result+="${M}m "
    ((S > 0)) && result+="${S}s "
    result+="${MS}ms"
    echo $result
}

# Function that runs just before the prompt is displayed
_prompt_command() {
    local exit_code=$?
    _DURATION="  $(_timer_stop) "
    unset timer
    if [[ $exit_code -eq 0 ]]; then
        _EXIT_BG="20;184;121" # green
        _EXIT_FG="0;0;0"
    elif [[ $exit_code -eq 130 ]]; then # 130 is the exit code for Ctrl+C
        _EXIT_BG="204;166;51" # yellow
        _EXIT_FG="0;0;0"
    else
        _EXIT_BG="205;49;49" #  red
        _EXIT_FG="255;255;255"
    fi
    # Sync bash history between all open terminals
    history -a   # Append this sessions bash history to the history file
    history -n   # Read new lines other sessions have added to the bash history file
}

# Run _timer_start before each simple command (DEBUG) and before each interrupt (INT, i.e. Ctrl+C)
trap _timer_start DEBUG INT
# PROMPT_COMMAND must be a single command so that it matches BASH_COMMAND in _timer_start, otherwise the timer will be
# reset just before it is stopped because the DEBUG trap is triggered by PROMPT_COMMAND
PROMPT_COMMAND="_prompt_command"
