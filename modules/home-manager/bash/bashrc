# Exit if the shell is not running interactively.
[[ $- != *i* ]] && return

#    ▗▄▄▖ ▗▄▄▄▖ ▗▄▖ ▗▄▄▄ ▗▖   ▗▄▄▄▖▗▖  ▗▖▗▄▄▄▖
#    ▐▌ ▐▌▐▌   ▐▌ ▐▌▐▌  █▐▌     █  ▐▛▚▖▐▌▐▌
#    ▐▛▀▚▖▐▛▀▀▘▐▛▀▜▌▐▌  █▐▌     █  ▐▌ ▝▜▌▐▛▀▀▘
#    ▐▌ ▐▌▐▙▄▄▖▐▌ ▐▌▐▙▄▄▀▐▙▄▄▖▗▄█▄▖▐▌  ▐▌▐▙▄▄▖

bind "TAB: menu-complete"               # Use TAB to auto-complete
bind "set completion-ignore-case on"    # Do not differentiate between upper and lower case when completing
bind "set echo-control-characters off"  # Do not print out control characters in a visible format (e.g. ^C)
# When performing completion in the middle of a word move the cursor past the completed text instead of inserting the completed text at the cursor position
# for example if your cursor was after the u in cd modules it will just move your cursor to the end instead of changing it to cd modulesles
bind "set skip-completed-text on"
bind '"\e[A": history-search-backward'  # Use ↑ to search backwards through your history for the text in the prompt
bind '"\e[B": history-search-forward'   # Use ↓ to search forwards through your history for the text in the prompt
bind '"\C-h": backward-kill-word'       # Use Ctrl+Backspace to delete the last word in the prompt
bind '"\e[1;3D": "cd ..\n"'             # Use Alt+← to go up one directory
bind '"\e[1;3C": "cd -\n"'              # Use Alt+→ to go to the previous directory
bind '"\es": "\C-asudo \C-e"'           # Use Alt+s to prepend sudo to the current command
bind '"\C-l": clear-display'            # Use Ctrl+L to clear the screen (override the default clear-screen, which does just scrolls the screen up)
bind '"\C-r": "source ~/nix/modules/home-manager/bash/bashrc\n"'     # Use Ctrl+R to reload the bashrc file from my nix configuration
if [[ -n $TMUX ]]; then
    bind '"\C-w": "tmux detach &> /dev/null\n"' # Use Ctrl+W to detach from the current tmux session
fi
# bind "set editing-mode vi"              # Use vi keybindings in the terminal (seems to prevent the use of the up and down arrow keys)
# bind "set show-all-if-ambiguous on"     # print out all matching files/directories if there are multiple possibilities
# bind "set colored-stats on"             # show directories in a different color when show-all-if-ambiguous is enabled
# bind "set colored-completion-prefix on" # show the part of the completed text that was already typed in a different color when show-all-if-ambiguous is enabled

#     ▗▄▄▖▗▖   ▗▄▄▄▖     ▗▄▖ ▗▖  ▗▖▗▄▄▄▖▗▄▄▖ ▗▖    ▗▄▖▗▖  ▗▖▗▄▄▖
#    ▐▌   ▐▌     █      ▐▌ ▐▌▐▌  ▐▌▐▌   ▐▌ ▐▌▐▌   ▐▌ ▐▌▝▚▞▘▐▌
#    ▐▌   ▐▌     █      ▐▌ ▐▌▐▌  ▐▌▐▛▀▀▘▐▛▀▚▖▐▌   ▐▛▀▜▌ ▐▌  ▝▀▚▖
#    ▝▚▄▄▖▐▙▄▄▖▗▄█▄▖    ▝▚▄▞▘ ▝▚▞▘ ▐▙▄▄▖▐▌ ▐▌▐▙▄▄▖▐▌ ▐▌ ▐▌ ▗▄▄▞▘

# Add the ability to cd up several directories using additional dots after cd ..
# For example, cd ... goes up two directories
cd() {
    if [[ $1 == ..+(.) ]]; then # requires extglob to be enabled
        # Length of the argument (which is all .s)
        local n=${#1}
        local ups=""
        local i=1
        # Build a string like ../, ../../, ../../../
        while [ $i -lt $n ]; do
            ups="../$ups"
            i=$((i + 1))
        done
        builtin cd "$ups" # Use builtin to prevent infinite recursion
    else
        builtin cd "$@"
    fi
}

# If nix-shell is run without --run, --command or --pure then automatically start an interactive bash shell (so .bashrc is sourced)
nix-shell() {
    if [[ " $* " == *" --run "* || " $* " == *" --command "* || " $* " == *" --pure "* ]]; then
        command nix-shell "$@"
    else
        command nix-shell "$@" --run "bash -i"
    fi
}

#  ▗▄▄▖  ▗▄▖  ▗▄▄▖▗▖ ▗▖    ▗▄▄▖ ▗▄▄▖  ▗▄▖ ▗▖  ▗▖▗▄▄▖▗▄▄▄▖
#  ▐▌ ▐▌▐▌ ▐▌▐▌   ▐▌ ▐▌    ▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌▐▛▚▞▜▌▐▌ ▐▌ █
#  ▐▛▀▚▖▐▛▀▜▌ ▝▀▚▖▐▛▀▜▌    ▐▛▀▘ ▐▛▀▚▖▐▌ ▐▌▐▌  ▐▌▐▛▀▘  █
#  ▐▙▄▞▘▐▌ ▐▌▗▄▄▞▘▐▌ ▐▌    ▐▌   ▐▌ ▐▌▝▚▄▞▘▐▌  ▐▌▐▌    █

parse_git_branch() {
    # Check if we are in a git repository (2> &1 redirects stderr to stdout, which is going to /dev/null)
    if git rev-parse --git-dir >/dev/null 2>&1; then
        # Get the current branch name or commit hash
        local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

        # Check if we are in a detached HEAD state
        if [[ $branch = "HEAD" ]]; then
            # Get the current commit hash
            local commit_hash=$(git rev-parse --short HEAD 2>/dev/null)
            if [[ $commit_hash != "" ]]; then
                echo "⚠️ $commit_hash"
            else
                echo "  "
            fi
        else
            # Get the ahead/behind status
            local status=$(git status -sb 2>/dev/null)
            local ahead_behind=""
            if [[ $status =~ \[ahead\ [0-9]+ ]]; then
                local ahead_count=$(echo $status | grep -oP '(?<=\[ahead )\d+')
                ahead_behind="↑$ahead_count"
            fi
            if [[ $status =~ behind\ [0-9]+\] ]]; then
                local behind_count=$(echo $status | grep -oP '(?<=behind )\d+(?=\])')
                ahead_behind="$ahead_behind↓$behind_count"
            fi
            echo " $branch $ahead_behind"
        fi
    fi
}

# Find more icons here: https://www.nerdfonts.com/cheat-sheet
declare -A DIR_ICONS=(
    [".android"]=" "
    ["Android"]=" "
    ["bin"]=" "
    [".cache"]="󱘿 "
    [".config"]=" "
    ["Desktop"]=" "
    ["Development"]="󰘦 "
    [".docker"]=" "
    ["Documents"]="󱔗 "
    ["Downloads"]="󰉍 "
    ["etc"]=" "
    [".git"]=" "
    [".github"]=" "
    [".java"]=" "
    ["lib"]=" "
    ["lib64"]=" "
    ["media"]="󰕓 "
    ["mnt"]=" "
    [".mozilla"]="󰈹 "
    ["Music"]="󱍙 "
    ["nix"]=" "
    ["nixos"]=" "
    [".npm"]=" "
    ["opt"]=" "
    ["Pictures"]="󰉏 "
    ["proc"]=" "
    ["Public"]=" "
    ["root"]="󰉐 "
    ["tmp"]=" "
    [".tmux"]=" "
    ["usr"]="󰪋 "
    ["var"]=" "
    ["Videos"]="󰨜 "
    [".vim"]=""
    [".vscode"]="󰨞 "
)

# Alternative to \w that prints the current directory in a more concise way:
# Print / or ~ if we are in the root or home directory
# Print the exact path if we are in a subdirectory of root or home
# Print /…/directory if we are in a subdirectory of a subdirectory of root
# Print ~/…/directory if we are in a subdirectory of a subdirectory of home
# Print ~/<icon>/directory if we are in a subdirectory of a subdirectory of home and the home subdirectory has an icon
# Print ~/<icon>/…/directory if we are more than 2 subdirectories deep in home and the home subdirectory has an icon
parse_directory() {
    local directory=$(basename "$PWD")
    local parent_dir=$(basename "$(dirname "$PWD")")
    if [[ $PWD == "$HOME"* ]]; then # if we are in a subdirectory of a subdirectory of home
        if [[ $PWD = $HOME ]]; then
            echo "~"
            return
        elif [[ $PWD = "$HOME/$directory" ]]; then # if we are in a subdirectory of home
            echo "~/$directory"
            return
        fi
        local home_subdir=$(echo ${PWD#$HOME/} | cut -d "/" -f 1)
        local icon="${DIR_ICONS[$home_subdir]}"
        if [[ -n $icon ]]; then # if the parent directory has an icon
            if [[ $PWD = "$HOME/$parent_dir/$directory" ]]; then
                echo "~/$icon/$directory"
            else
                echo "~/$icon/…/$directory"
            fi
        else
            echo "~/…/$directory"
        fi
    else # if we are in a subdirectory of root
        if [[ $PWD = "/" || $PWD = "/$directory" ]]; then
            echo "$PWD"
            return
        fi
        local subdir=$(echo $PWD | cut -d "/" -f 2)
        local icon="${DIR_ICONS[$subdir]}"
        if [[ -n $icon ]]; then # if the parent directory has an icon
            if [[ $PWD = "/$parent_dir/$directory" ]]; then
                echo "/$icon/$directory"
            else
                echo "/$icon/…/$directory"
            fi
        else
            echo "/…/$directory"
        fi
    fi
}

distro_icon() {
    if [[ -e "/etc/os-release" ]]; then
        local distro=$(source /etc/os-release && echo $ID)
    else
        local distro="termux"
    fi
    declare -A distro_icons=(
        ["debian"]=" "
        ["ubuntu"]=" "
        ["nixos"]=" "
        ["termux"]=" "
    )
    declare -A distro_colors=(
        ["debian"]="168;0;48"
        ["ubuntu"]="233;84;32"
        ["nixos"]="126;183;226"
        ["termux"]="164;198;57"
    )
    local icon="${distro_icons[$distro]:- }"
    local color="${distro_colors[$distro]:-33}"
    unset distro_icons distro_colors
    echo "\[\e[48;2;${1}m\e[38;2;${color}m\]${icon}"
}

# Function that displays 󰢹 before the prompt if the terminal is being accessed via SSH
ssh_session() {
    if [[ -n $SSH_CLIENT ]]; then
        echo "\[\e[94m\]󰢹 \[\e[0m\]";
    fi
}

# Function that displays  before the prompt if we are in a nix shell, or  󰌪 if we are in a pure nix shell (pure: no system software included)
nix_shell() {
    if [[ -n $IN_NIX_SHELL ]]; then
        local pure=$(test "$IN_NIX_SHELL" = "pure" && echo "󰌪 ")
        echo "\[\e[38;2;126;183;226m\] \[\e[38;2;159;226;126m\]$pure\[\e[0m\]"
    fi
}

# Timer for measuring the time it takes to run a command
timer_start() {
    [[ -n $COMP_LINE ]] && return # do nothing if completing
    [[ $BASH_COMMAND = $PROMPT_COMMAND ]] && return
    timer=$(date +%s%3N)
}

# Stop the timer and print the time it took to run the command in a human readable format
timer_stop() {
    local end_time=$(date +%s%3N)
    if [[ -z $timer ]]; then
        echo "-"
        return
    fi
    local T=$((end_time - timer))
    local MS=$((T % 1000))
    local S=$((T / 1000 % 60))
    local M=$((T / 1000 / 60 % 60))
    local H=$((T / 1000 / 60 / 60 % 24))
    local D=$((T / 1000 / 60 / 60 / 24))
    local result=""
    ((D > 0)) && result+="${D}d "
    ((H > 0)) && result+="${H}h "
    ((M > 0)) && result+="${M}m "
    ((S > 0)) && result+="${S}s "
    result+="${MS}ms"
    echo $result
}

# Function that runs just before the prompt is displayed
prompt_command() {
    local exit_code=$?
    duration=$(timer_stop)
    unset timer
    if [[ $exit_code -eq 0 ]]; then
        exit_bg="20;184;121" # green
        exit_fg=30
    elif [[ $exit_code -eq 130 ]]; then # 130 is the exit code for Ctrl+C
        exit_bg="204;166;51" # yellow
        exit_fg=30
    else
        exit_bg="205;49;49" #  red
        exit_fg=37
    fi
    # Sync bash history between all open terminals
    history -a   # Append this sessions bash history to the history file
    history -n   # Read new lines other sessions have added to the bash history file
}

# Run timer_start before each simple command (DEBUG) and before each interrupt (INT, i.e. Ctrl+C)
trap timer_start DEBUG INT
# PROMPT_COMMAND must be a single command so that it matches BASH_COMMAND in timer_start, otherwise the timer will be
# reset just before it is stopped because the DEBUG trap is triggered by PROMPT_COMMAND
PROMPT_COMMAND="prompt_command"

bg1="102;102;102" #    grey
fg1=30 #               black
usr_fg=32 #            green
dir_bg="255;255;255" # white
git_bg="20;151;184" #  blue
edge="" # other options:          

PS1="$(ssh_session)$(nix_shell)"
PS1+="\[\e[38;2;${bg1}m\]$(distro_icon $bg1)\[\e[1;${usr_fg}m\e[48;2;${bg1}m\]\u \[\e[0m\e[38;2;${bg1}m\e[48;2;${dir_bg}m\]$edge"
PS1+="\[\e[${fg1}m\] \$(parse_directory) \[\e[48;2;${git_bg}m\e[38;2;${dir_bg}m\]$edge"
PS1+="\[\e[${fg1}m\] \$(parse_git_branch)\[\e[0m\e[48;2;\${exit_bg}m\e[38;2;${git_bg}m\]$edge"
PS1+=" \[\e[\${exit_fg}m\] \${duration} \[\e[48;2;${bg1}m\e[38;2;\${exit_bg}m\]$edge"
PS1+="\[\e[1;37m\]\\$\[\e[0m\e[38;2;${bg1}m\]$edge\[\e[0m\] "

unset distro_icon ssh_session nix_shell bg1 fg1 usr_fg dir_bg git_bg edge

#     ▗▄▄▖▗▖ ▗▖▗▄▄▖  ▗▄▄▖ ▗▄▖ ▗▄▄▖
#    ▐▌   ▐▌ ▐▌▐▌ ▐▌▐▌   ▐▌ ▐▌▐▌ ▐▌
#    ▐▌   ▐▌ ▐▌▐▛▀▚▖ ▝▀▚▖▐▌ ▐▌▐▛▀▚▖
#    ▝▚▄▄▖▝▚▄▞▘▐▌ ▐▌▗▄▄▞▘▝▚▄▞▘▐▌ ▐▌

echo -ne "\e[?5 q"
# 1: blinking block
# 2: block
# 3: blinking underline
# 4: underline
# 5: blinking bar
# 6: bar
